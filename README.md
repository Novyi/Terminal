1.	Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
chdir("/tmp")
2.	Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
Использовал команду: strace /bin/bash -c 'file'.
По всей видимости  база здесь: openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
3.	Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
Найти открытый файл с помощью программы lsof:
$ sudo lsof | grep filename
Способ 1:> filename
Способ 2: echo -n > filename
Способ 3: cat /dev/null > filename или  cat /dev/null >| filename
Способ 4: cp /dev/null filename
Способ 5: truncate -s 0 filename
Очистка множества файлов: truncate -s 0 $(ls -1 *.txt)
4.	Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Не нашел конкретно про CPU, RAM, IO.
Найти зомби-процессы: ps aux | grep defunct. Или просто top.
Завершение дочернего процесса через Родительский процесс с помощью функций -  wait и waitpid.
5.	В iovisor BCC есть утилита opensnoop:
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.
Использовал команду: sudo opensnoop -bpfcc
PID    COMM               FD ERR PATH
791    vminfo              5   0 /var/run/utmp
578    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
578    dbus-daemon        17   0 /usr/share/dbus-1/system-services
578    dbus-daemon        -1   2 /lib/dbus-1/system-services
578    dbus-daemon        17   0 /var/lib/snapd/dbus-1/system-services/
584    irqbalance          6   0 /proc/interrupts
6.	Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
uname - утилита, которая выводит основную информацию об имени операционной системы и аппаратном обеспечении системы. 
Альтернативное местоположение в /proc по man uname не нашел. В man proc есть /proc/sys/kernel, может это оно?
7.	Чем отличается последовательность команд через ; и через && в bash? Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
Есть ли смысл использовать в bash &&, если применить set -e?
; - Разделитель команд. Позволяет записывать более одной команды в строке
&& - для последовательного запуска команд. Если в первой ошибка, вторая не начинает работать
set –e  - Если задано, оболочка завершает работу, когда простая команда из списка команд завершается ненулевым значением (FALSE). Это не делается в ситуациях, когда код выхода уже проверен (if, while, until,||, &&).    && не имеет смысла, так как при ошибке, выполнение команд прекратится.
8.	Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
-e: параметр -e указывает оболочке выйти, если команда дает ненулевой статус выхода. Оболочка завершает работу при сбое команды.
-u: опция -u обрабатывает неустановленные или неопределенные переменные, за исключением специальных параметров, таких как подстановочные знаки (*) или «@», как ошибки во время раскрытия параметра. С выводом в stderr текста ошибки и выполнит завершение неинтерактивного вызова.
-x: опция -x печатает аргументы команды во время выполнения
o pipefail: Если какая-либо команда в конвейере завершится неудачно, этот код возврата будет использоваться в качестве кода возврата всего конвейера. По умолчанию код возврата конвейера совпадает с кодом последней команды, даже если она выполнена успешно.
Данный режим может показать незаметные ошибки.
9.	Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
Часто встречающийся статус у процессов:
S – во сне с прерыванием (ожидающие события для завершения)
I – неработающие потоки ядра
Доп.символы:
<    высокий приоритет
               N    низкий приоритет
               L    есть страницы зафиксированные в памяти
               s    лидер сессии
               l    многопотоковый
               +    в главной группе процессов






 







































